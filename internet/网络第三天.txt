TCP的特点:可靠的有连接的通信

三次握手:
1、客户端要发送一个SYN=1的数据包给服务器
2、服务器接收到后回一个数据包(SYN=1,ACK=1)
3、客户端收到服务器的数据包后再给服务器回一个ACK=1的数据包 

四次挥手:
1、客户端要发送一个FIN=1的数据包给服务器
2、服务器给客户端回一个ACK=1的数据包   客户端的发送端和服务器的接收端被关闭
3、服务器给客户端发送FIN=1数据包
4、客户端给服务器回一个ACK=1的数据包   客户端的接收端和服务器的发送端被关闭

TCP服务器端:
1、创建套接字 socket();
2、填充服务器的地址信息
3、绑定服务器
4、监听 listen(,10);
5、数据接收的文件描述符 = accept(建立连接的文件描述符，客户端的地址信息，&len);
6、接收数据 recv();

TCP的客户端:
1、创建套接字
2、填充服务器的地址信息
3、使用connect()连接
4、发送数据 send();

TCP的循环服务器：
socket()
bind()
listen()

while(1)
{
	accept();
}

任何的服务器模型都不是完美的。

TCP的并发服务器(可以多进程实现，也可以多线程实现——一般不使用多线程实现)：

IO模型:
阻塞:读阻塞(没有数据、有数据但是内核缓存区未满)和写阻塞
非阻塞:
异步IO:这里的异步使用到了一种信号(SIGIO)，这个信号是由IO操作产生的。
	   可以用于UDP，不用于TCP。
多路复用select():

int select(int nfds,fd_set *readfds，fd_set *writefds,fd_set *execptfds,struct timeval *t);

nfds:代表最大的文件描述符加1
readfds:代表的是具有读属性的文件描述符表(表中存放了一堆的文件描述符)
writefds：代表的是具有写属性的文件描述符表
execptfds:代表除了读和写之外的文件描述符表
t:代表的超时属性
返回值:成功返回值为1|2|3(根select使用到的文件描述符表的个数有关)，出错返回-1，超时返回0

函数功能:如果没有文件描述符就绪则阻塞，有文件描述符就绪则唤醒。
		 一张表中最初维护了多个文件描述符，只要有就绪的文件描述符，则其它未就绪的文件描述符会被select清空

int FD_ZERO(fd_set *); 清0文件描述符表
void FD_SET(int,fd_set *);将文件描述符添加到文件描述符表中
int FD_ISSET(int fd,fd_set *);判断fd是否在文件描述符表中(本质就是判断具体哪个文件描述符唤醒的select) 这个宏的返回值为非0则成立



作业:实现一个tcp的并发服务器
	 写一个TCP客户端，执行客户端时会出现一个菜单:
	 *****1.查询服务器中某个文件夹的内容 2.从服务器中下载文件*****